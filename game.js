
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const { Engine, World, Bodies, Body, Events } = Matter;

const engine = Engine.create();
const world = engine.world;
engine.gravity.y = 1.2;

const fruits = [];
const RADIUS = 30;

let waitingFruitX = 270;
let gameOver = false;
let dropping = false;
let moveLeft = false;
let moveRight = false;
let leftPressed = false;
let rightPressed = false;
let score = 0;

const FRUIT_TYPES = [
  "stella",
  "dana",
  "erwin",
  "jin",
  "lily",
  "chii",
  "haru",
  "ephnel",
  "iris",
  "leenabi",
  "grouton"
];





const FRUIT_IMAGES = {}; // ‚úÖ Î∞òÎìúÏãú Ï†ÑÏó≠Ïóê ÏûàÏñ¥Ïïº Ìï®






const FRUIT_COLORS = {
  stella: "#ffb6c1",
  dana: "#ffc0cb",
  erwin: "#ffa07a",
  jin: "#f4a460",
  lily: "#f5deb3",
  chii: "#dda0dd",
  haru: "#87cefa",
  ephnel: "#98fb98",
  iris: "#ff69b4",
  leenabi: "#cd5c5c",
  grouton: "#d2b48c"
};



// ÏôºÏ™Ω Î≤Ω
const wallLeft = Bodies.rectangle(0, 360, 10, 720, { isStatic: true });

// Ïò§Î•∏Ï™Ω Î≤Ω
const wallRight = Bodies.rectangle(540, 360, 10, 720, { isStatic: true });

// ÏõîÎìúÏóê Ï∂îÍ∞Ä
World.add(world, [wallLeft, wallRight]);










const ground = Bodies.rectangle(270, 710, 540, 40, {  // ÎëêÍªò 20 ‚Üí 40
  isStatic: true,
  friction: 10
  
});
World.add(world, ground);



let currentFruitType = getRandomFruitType();  // ÏßÄÍ∏à ÎìúÎûçÌï† Í≥ºÏùº



function getNextType(type) {
  const index = FRUIT_TYPES.indexOf(type);
  return index >= 0 && index < FRUIT_TYPES.length - 1 ? FRUIT_TYPES[index + 1] : null;
}



window.addEventListener("keydown", (e) => {
  if (gameOver) return;

  if (e.code === "KeyA" && !leftPressed) {
    moveLeft = true;
    leftPressed = true; // üëâ Ï§ëÎ≥µ Î∞©ÏßÄÏö©
  }

  if (e.code === "KeyD" && !rightPressed) {
    moveRight = true;
    rightPressed = true;
  }

  if (e.code === "Space" && !dropping && !gameOver) {
    createFruit(currentFruitType, waitingFruitX);  // ‚úÖ ÌòÑÏû¨ Í≥ºÏùº ÎìúÎûç
    currentFruitType = nextFruitType;              // ‚úÖ Îã§ÏùåÏùÑ ÌòÑÏû¨Î°ú
    nextFruitType = getRandomFruitType();          // ‚úÖ ÏÉàÎ°úÏö¥ ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÑ§Ï†ï
    dropping = true;
  
    setTimeout(() => {
      dropping = false;
    }, 500);
  }
});

window.addEventListener("keyup", (e) => {
  if (e.code === "KeyA") {
    moveLeft = false;
    leftPressed = false;
  }

  if (e.code === "KeyD") {
    moveRight = false;
    rightPressed = false;
  }
});


const MAX_SPEED = 8;           // Ïù¥Îèô ÏÜçÎèÑ Ï†úÌïú
const MAX_ANGULAR = 0.3;       // ÌöåÏ†Ñ ÏÜçÎèÑ Ï†úÌïú


Events.on(engine, "collisionStart", (event) => {
  const pairs = event.pairs;
  for (let pair of pairs) {
    const a = pair.bodyA;
    const b = pair.bodyB;

    if (!a.fruitType || !b.fruitType) continue;
    if (a === b) continue;
    if (!fruits.includes(a) || !fruits.includes(b)) continue;

    // ‚úÖ ÏÜçÎèÑ Ï†àÎ∞òÏúºÎ°ú Ï§ÑÏù∏ Îí§ ÏÉÅÌïúÏÑ† Ï†ÅÏö©
    for (const body of [a, b]) {
      let vx = body.velocity.x * 0.5;
      let vy = body.velocity.y * 0.5;
      let angular = body.angularVelocity * 0.5;

      // ÏÜçÎèÑ Ï†úÌïú
      const speed = Math.sqrt(vx * vx + vy * vy);
      if (speed > MAX_SPEED) {
        const ratio = MAX_SPEED / speed;
        vx *= ratio;
        vy *= ratio;
      }

      // ÌöåÏ†Ñ Ï†úÌïú
      if (Math.abs(angular) > MAX_ANGULAR) {
        angular = Math.sign(angular) * MAX_ANGULAR;
      }

      Body.setVelocity(body, { x: vx, y: vy });
      Body.setAngularVelocity(body, angular);
    }

    // ‚úÖ ÏßÑÌôî Î°úÏßÅ Ïú†ÏßÄ
    if (a.fruitType !== b.fruitType) continue;

    const fruitType = a.fruitType;
    const nextType = getNextType(fruitType);
    if (!nextType) continue;

    const newX = (a.position.x + b.position.x) / 2;
    const newY = (a.position.y + b.position.y) / 2 - RADIUS;

    World.remove(world, a);
    World.remove(world, b);
    fruits.splice(fruits.indexOf(a), 1);
    fruits.splice(fruits.indexOf(b), 1);

    score += FRUIT_SCORES[nextType] || 0;
    createFruit(nextType, newX, newY, 1.5);
  }
});



const MOVE_SPEED = 9;
const FRUIT_STATS = {
  stella:  { radius: 20, density: 0.001 },
  dana:    { radius: 30, density: 0.001 },
  erwin:   { radius: 40, density: 0.001 },
  jin:     { radius: 50, density: 0.001 },
  lily:    { radius: 60, density: 0.001 },
  chii:    { radius: 75, density: 0.001 },
  haru:    { radius: 95, density: 0.001 },
  ephnel:  { radius: 115, density: 0.001 },
  iris:    { radius: 130, density: 0.001 },
  leenabi: { radius: 150, density: 0.001 },
  grouton: { radius: 170, density: 0.001 }
};




function createFruit(type = "stella", x = 270, y = 50, scale = 1) {
  const { radius, density } = FRUIT_STATS[type] || { radius: 30, density: 0.001 };

  const fruit = Bodies.circle(x, y, radius, {
    restitution: 0.3,
    friction: 0.05,
    frictionAir: 0.01,
    density: density,
    label: type,
  });

  // ‚úÖ ÏÉùÏÑ± Ïù¥ÌõÑÏóê Ìï†ÎãπÌï¥Ïïº Ï†ïÏÉÅ ÏûëÎèôÌï®
  fruit.createdAt = Date.now(); // ÏÉùÏÑ± ÏãúÍ∞Å ÏÑ§Ï†ï
  fruit.fruitType = type;
  fruit.radius = radius;
  fruit.scale = scale;
  fruit.growTimer = scale > 1 ? 10 : 0;
  fruit.visualAngle = 0;
  fruit.spinDir = Math.random() < 0.5 ? -1 : 1;

  fruits.push(fruit);
  World.add(world, fruit);

  return fruit;
}





function update() {
  
  const lastFruit = fruits[fruits.length - 1];
  const GAME_OVER_HEIGHT = 80;

  // ÏãúÍ∞ÅÏö© ÌöåÏ†ÑÍ∞í ÎàÑÏ†Å
for (const fruit of fruits) {
  const vx = fruit.velocity.x;
  const vy = fruit.velocity.y;
  const speed = Math.sqrt(vx * vx + vy * vy);

  // ÌöåÏ†Ñ Î∞©Ìñ• Ï¥àÍ∏∞Ìôî (Ïïà ÎêòÏñ¥ ÏûàÏúºÎ©¥)
  if (fruit.spinDir === undefined) {
    fruit.spinDir = Math.random() < 0.5 ? -1 : 1;
  }

  // ÏãúÍ∞Å ÌöåÏ†Ñ Í∞ÅÎèÑ ÎàÑÏ†Å
  fruit.visualAngle += fruit.spinDir * speed * 0.03;
}

  Engine.update(engine);


  // ‚úÖ Í≤åÏûÑ Ïò§Î≤Ñ Í∞êÏßÄ
// ‚úÖ Ï§ëÎ≥µ Î£®ÌîÑ Ï†úÍ±∞!
const now = Date.now();
const IMMUNE_TIME = 1000; // 1Ï¥à Î¨¥Ï†Å

for (const fruit of fruits) {
  if (!fruit.createdAt || now - fruit.createdAt < IMMUNE_TIME) continue; // üí• 1Ï¥à ÎèôÏïà Ï†úÏô∏

  const vy = fruit.velocity.y;
  const vx = fruit.velocity.x;
  const speed = Math.sqrt(vx * vx + vy * vy);
  const yTop = fruit.position.y - (fruit.radius || RADIUS);

  if (yTop < 10 && speed < 0.05) {
    gameOver = true;
    console.log("‚ò†Ô∏è Game Over: Ï≤úÏû• Î∂ÄÍ∑º Í≥ºÏùº Í∞êÏßÄÎê®");
    break;
  }
}


  


  if (!dropping && !gameOver) {
    if (moveLeft) {
      waitingFruitX = Math.max(RADIUS, waitingFruitX - MOVE_SPEED);
    }
    if (moveRight) {
      waitingFruitX = Math.min(canvas.width - RADIUS, waitingFruitX + MOVE_SPEED);
    }
  }

  if (lastFruit && dropping && !gameOver) {
    const bottom = lastFruit.position.y + RADIUS;
    const velocity = lastFruit.velocity;

    const isLanded =
      (bottom >= canvas.height - 10 || velocity.y === 0) &&
      Math.abs(velocity.y) < 0.5 &&
      Math.abs(velocity.x) < 0.5;

    if (isLanded) {
      // ÌïÑÏöîÏãú Ï≤òÎ¶¨
    }
  }
}





function draw() {
  // ‚úÖ Ï†úÏùº Î®ºÏ†Ä ÌôîÎ©¥ Ï†ÑÏ≤¥ ÌÅ¥Î¶¨Ïñ¥
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!dropping && !gameOver) {
    const previewRadius = FRUIT_STATS[currentFruitType]?.radius || RADIUS;
    const fruitY = 50;
    const fruitBottom = fruitY + previewRadius;
    const fruitCenterX = waitingFruitX;
  
    let minY = canvas.height;
    let touching = false;
  
    for (const fruit of fruits) {
      const dx = Math.abs(fruit.position.x - fruitCenterX);
      const dy = fruit.position.y - fruitY;
      const distance = Math.sqrt(dx * dx + dy * dy);
  
      // ‚úÖ ÎãøÏïòÎäîÏßÄ Ïó¨Î∂Ä - Ï§ëÏã¨ Í∞Ñ Í±∞Î¶¨ + Ïó¨Ïú†
      if (distance <= fruit.radius + 4) {
        touching = true;
        break;
      }
  
      // ‚úÖ ÌåêÏ†ï Ïó¨Ïú†: Í≥ºÏùºÏù¥ Ï∂©Î∂ÑÌûà Í∑ºÏ†ëÌïú Í≤ΩÏö∞ÏóêÎßå ÎåÄÏÉÅ Ìè¨Ìï®
      const X_TOLERANCE = fruit.radius * 1; // ‚òÖ ÌòÑÏã§Ï†ÅÏù∏ ÌóàÏö© Ïò§Ï∞®
      if (dx < X_TOLERANCE && fruit.position.y > fruitBottom) {
        minY = Math.min(minY, fruit.position.y);
      }
    }
  
    if (!touching) {
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.moveTo(fruitCenterX, fruitBottom);
      ctx.lineTo(fruitCenterX, minY);
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }
  
  
  
  
  
  
  
  
  
  



  // ‚úÖ Í≤åÏûÑÏò§Î≤Ñ Í≤ΩÍ≥† Í∞ÄÏù¥ÎìúÎùºÏù∏
  const dangerLineY = 30;
  const lineNear = fruits.some(fruit => (fruit.position.y - fruit.radius) < dangerLineY + 20);
  ctx.beginPath();
  ctx.moveTo(0, dangerLineY);
  ctx.lineTo(canvas.width, dangerLineY);
  ctx.lineWidth = lineNear ? 4 : 1;
  ctx.strokeStyle = lineNear ? "#ff0000" : "#ff8888";
  ctx.setLineDash([6, 4]);
  ctx.stroke();
  ctx.setLineDash([]); // ÏõêÎûòÎåÄÎ°ú Î≥µÏõê

  // ‚úÖ Í≤åÏûÑ Ïò§Î≤Ñ ÌÖçÏä§Ìä∏
// ‚úÖ Ïò§Î•∏Ï™Ω ÏÉÅÎã® ÎØ∏Î¶¨Î≥¥Í∏∞ ... Í∑∏ ÏïÑÎûòÏóê Ï∂îÍ∞Ä
const nextImg = FRUIT_IMAGES[nextFruitType];
if (nextImg && nextImg.complete) {
  ctx.drawImage(nextImg, canvas.width - 60 - 20, 60 - 20, 40, 40);
} else {
  ctx.fillStyle = FRUIT_COLORS[nextFruitType] || "#999";
  ctx.beginPath();
  ctx.arc(canvas.width - 60, 60, 20, 0, Math.PI * 2);
  ctx.fill();
}





  // ‚úÖ Í≥ºÏùº Í∑∏Î¶¨Í∏∞
  for (const fruit of fruits) {
    if (fruit.growTimer > 0) {
      fruit.growTimer--;
      fruit.scale = 1 + (fruit.growTimer / 10) * 0.5;
    } else {
      fruit.scale = 1;
    }

    const scale = fruit.scale || 1;
    const radius = (fruit.radius || RADIUS) * scale;
    const img = FRUIT_IMAGES[fruit.fruitType];

    if (img && img.complete) {
      ctx.save();
      ctx.translate(fruit.position.x, fruit.position.y);
      ctx.rotate(fruit.visualAngle);
      ctx.drawImage(img, -radius, -radius, radius * 2, radius * 2);
      ctx.restore();
    } else {
      ctx.fillStyle = FRUIT_COLORS[fruit.fruitType] || "#ccc";
      ctx.beginPath();
      ctx.arc(fruit.position.x, fruit.position.y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ‚úÖ Ï†êÏàò ÌëúÏãú
  ctx.fillStyle = "#333";
  ctx.font = "24px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`Score: ${score}`, 20, 30);

  // ‚úÖ ÌòÑÏû¨ ÎåÄÍ∏∞ Ï§ë Í≥ºÏùº
  if (!dropping && !gameOver) {
    const previewRadius = FRUIT_STATS[currentFruitType]?.radius || RADIUS;
    const img = FRUIT_IMAGES[currentFruitType];
    if (img && img.complete) {
      ctx.drawImage(img, waitingFruitX - previewRadius, 50 - previewRadius, previewRadius * 2, previewRadius * 2);
    }
  }

  // ‚úÖ Ïò§Î•∏Ï™Ω ÏÉÅÎã® ÎØ∏Î¶¨Î≥¥Í∏∞
  ctx.fillStyle = "#666";
  ctx.font = "16px Arial";
  ctx.fillText("Next:", canvas.width - 100, 30);

  
  if (nextImg && nextImg.complete) {
    ctx.drawImage(nextImg, canvas.width - 60 - 20, 60 - 20, 40, 40);
  } else {
    ctx.fillStyle = FRUIT_COLORS[nextFruitType] || "#999";
    ctx.beginPath();
    ctx.arc(canvas.width - 60, 60, 20, 0, Math.PI * 2);
    ctx.fill();
  }

  // ‚úÖ üü• Îß® ÎßàÏßÄÎßâÏóê Í≤åÏûÑ Ïò§Î≤Ñ ÌÖçÏä§Ìä∏
if (gameOver) {
  // Î∞òÌà¨Î™Ö Ïñ¥ÎëêÏö¥ Î∞∞Í≤Ω
  ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
  ctx.fillRect(0, canvas.height / 2 - 60, canvas.width, 120);

  // ÎààÏóê Ïûò ÎùÑÎäî Ìù∞ÏÉâ ÌÖçÏä§Ìä∏
  ctx.fillStyle = "#fff";
  ctx.font = "48px Arial";
  ctx.textAlign = "center";
  ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 + 15);
}


}




let nextFruitType = getRandomFruitType(); // ÏµúÏ¥à ÎØ∏Î¶¨Î≥¥Í∏∞ Í≥ºÏùº

function getRandomFruitType() {
  const minIndex = 0;
  const maxIndex = 4; // 0~4 = 1Îã®Í≥Ñ~5Îã®Í≥Ñ
  const index = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;
  return FRUIT_TYPES[index];
}


window.addEventListener("keydown", (e) => {

  console.log("[KEYDOWN]", e.code);
  console.log("üîç dropping:", dropping, "gameOver:", gameOver);

  if (gameOver) return;

  if (e.code === "KeyA" && !moveLeft) {
    moveLeft = true;
  }
  if (e.code === "KeyD" && !moveRight) {
    moveRight = true;
  }

  if (e.code === "Space" && !dropping && !gameOver) {
    createFruit(currentFruitType, waitingFruitX);   // üîΩ ÌòÑÏû¨ ÌÉÄÏûÖ ÎìúÎûç
    currentFruitType = nextFruitType;               // ‚ñ∂Ô∏è ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÌòÑÏû¨Î°ú
    nextFruitType = getRandomFruitType();           // ‚ñ∂Ô∏è ÏÉà ÎØ∏Î¶¨Î≥¥Í∏∞ ÏÑ§Ï†ï
    dropping = true;
    setTimeout(() => {
      dropping = false;
    }, 500);
  }
  
});

window.addEventListener("keyup", (e) => {
  if (e.code === "KeyA") moveLeft = false;
  if (e.code === "KeyD") moveRight = false;
});


for (const type of FRUIT_TYPES) {
  const img = new Image();
  img.src = `images/${type}.png`; // ex: images/stella.png
  FRUIT_IMAGES[type] = img;
}

const FRUIT_SCORES = {
  stella: 1,
  dana: 3,
  erwin: 6,
  jin: 10,
  lily: 15,
  chii: 21,
  haru: 28,
  ephnel: 36,
  iris: 45,
  leenabi: 55,
  grouton: 66
};




function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
